**==顺序存储==**：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构
- 顺序存储结构**占用一片连续的存储空间**
- 知道一个元素的存储位置，就可以推出其他所有元素的存储位置

# 顺序表的定义
 
```c++
#define MaxSize 100 //线性表存储空间初始分配量
typedef struct{
	ElemType elem[MaxSize];
	int length;  //当前长度
}SqList;
```

***例:多项式$P_{n}(x)=p_{1}x^{e_{1}} + p_{2}x^{e_{2}}+\cdots + p_{m}x^{e_{m}}$转换成线性表$P=((p_1,e_1),(p_2,e_2),(p_m,e_m))$***

```c++
#define MAXSIZE1000  //多项式可能达到的最大长度
typedef struct {     //多项式非零项的定义
	float p;         //系数
	int e;           //指数
}Polynomial;

typedef struct{
	Polynomial *elem;      //存储空间的基地址
	int length;            //多项式中当前项的个数
}SqList;                   //多项式的顺序存储结构类型为SqList
```

一旦定义了顺序表存储结构，就可以使用C/C++语言实现各种基本运算。为了简单，假设ElemType为int类型，使用宏定义：
`typedef int Elemtype`

**建立顺序表***
由数组元素`a[0...n-1]`创建顺序表L，算法：
```c++
//构造顺序表
void CreateList(SqList*& L, ElemType a[], int n) 	//由数组a构造顺序表L，n为数组元素个数
{													
	int i = 0, k = 0;                               //k表示顺序表L的当前长度，初始值0
	L = (SqList*)malloc(sizeof(SqList));			//分配存放顺序表的空间
	while (i < n)									//循环扫描数组a的每个元素
	{												
		L->data[k] = a[i];							//将a[i]的值存放到L中
		k++; i++;									
	}
	L->length = k;									//设置顺序表L的长度
}
```

---
# 顺序表的基本运算法则

**1.初始化线性表：InitList(* &L)**
构造一个空的线性表L（只需分配线性表并将length设置为0）
```c++
//初始化顺序表
void InitList(SqList*& L)							//初始化顺序表L
{
	L = (SqList*)malloc(sizeof(SqList));			//分配存放顺序表的空间
	L->length = 0;									//设置顺序表L的长度为0
}
```


**2.销毁线性表**
释放线性表L所占用的空间
```c++
//销毁线性表
void DestroyList(SqList * &L)					    //销毁顺序表L
{
	free(L);										//释放顺序表L所占的空间	}					
```
本节顺序表是通过malloc函数分配存储空间的，当不再需要顺序表时务必调用DestroyList(SqList * &L)释放存储空间

**3.判断线性表是否为空**
```c++
bool ListEmpty(SqList* L)							//判断顺序表L是否为空
{
	return (L->length == 0);			
}
```

**4.求线性表的长度**
只需返回length域的值
```c++
//求线性表的长度
int ListLength(SqList* L)							//返回顺序表L的长度
{
	return L->length;								//返回顺序表L的长度
}
```

**5.输出线性表**
依次输出元素
```c++
//输出线性表
void DispList(SqList* L) 
{
	for(int i = 0; i < L->length; i++)				//循环扫描顺序表L的每个元素
	{
		std::cout << L->data[i] << " ";			    //输出顺序表L的每个元素
	}
}
```


**6.按序号求线性表中的元素**
如果i值正确（1<=i<=n），该运算用引用型参数e获取L中第i个元素的值，并返回
true，否则返回false。算法如下：
```c++
//按序号求线性表中的元素
bool  GetElem(SqList* L, int i, ElemType& e)
{
	if (i<1 || i>L->length)                              //判断i值的范围是否合法
		return false;
	e = L->data[i - 1];		
	return true;
}
```

**7.按元素值查找**
该运算顺序查找第一个值为，的元素的逻辑序号，若这样的元素不存在，则返回值为
0。
```c++
//按元素值查找
int LocateElem(SqList* L, ElemType e)
{
	int i = 0;
	while(i < L->length && L->data[i] != e)               //循环扫描顺序表L的每个元素
		i++;
	if(i>=L->length)                                      //若i值大于等于顺序表L的长度
		return 0;                                         //则返回0，表示查找失败
	else
		return i + 1;                                     //否则返回i+1，表示查找成功
}
```

**8.插入数据元素**
该运算在顺序表L的第 i 个位置上插入新元素e。如果i值不正确，返回false；否则将顺序表原来的第i个元素及以后的元素均后移一个位置，并从最后一个元素$a_n$开始移动，腾出一个空位置插入新元素，最后顺序表的长度增1并返回true
```c++
//插入数据元素
bool ListInsert(SqList*& L, int i, ElemType e)
{
	int k;
	if (i<1 || i>L->length + 1 || L->length==MAXSIZE )    //判断i值的范围是否合法
		return false;
	i--;                                                  //将顺序表L的第i个位置的序号值转换为数组下标值
	for (k = L->length; k > i ; k--)                      //将第i个元素及之后的元素后移
			L->data[k] = L->data[k-1];
	L->data[i] = e;                                       //将e赋值给第i个元素
	L->length++;                                          //顺序表L的长度增1
	return true;
}
```

**9.删除数据元素**
```c++
//删除数据元素
bool ListDelete(SqList*& L, int i, ElemType& e)
{
	int j;
	if(i<1 || i>L->length)                         //判断i值的范围是否合法
		return false;
	i--;
	e = L->data[i];                                //将被删除的元素值赋值给e
	for (j = i; j < L->length - 1; j++)            //将第i个元素之后的元素前移
		L->data[j] = L->data[j + 1];
	L->length--;                                   //顺序表L的长度减1
	return true;
}
```

---
